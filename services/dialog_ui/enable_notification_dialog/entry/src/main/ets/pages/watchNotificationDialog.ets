/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import bundleResourceManager from '@ohos.bundle.bundleResourceManager';
import display from '@ohos.display';
import window from '@ohos.window';
import { titleTrim } from '../common/utils';
import Constants from '../common/constant';
import fs from '@ohos.file.fs';
import configPolicy from '@ohos.configPolicy';
import { EnableNotificationDialog } from '../ServiceExtAbility/NotificationServiceExtAbility';
import { Callback} from '@ohos.base';
import UIExtensionContentSession from '@ohos.app.ability.UIExtensionContentSession';

const TAG = 'NotificationDialog_Service ';
const permission: Record<string, Resource> = {
  'label': $r('app.string.group_label_notification'),
  'icon': $r('app.media.ic_public_ring'),
  'reason': $r('app.string.reason'),
};

let storage = LocalStorage.getShared();

@Entry(storage)
@Component
struct NotificationDialogPage {
  @State isUpdate: number = -1;
  privacyDialogController: CustomDialogController = new CustomDialogController({
    builder: PermissionDialog({ isUpdate: $isUpdate }),
    autoCancel: false,
    alignment: DialogAlignment.TopStart,
    customStyle: false,
    onWillDismiss: (dismissDialogAction: DismissDialogAction) => {
      console.info(TAG, `dialog onWillDismiss reason= : ${JSON.stringify(dismissDialogAction.reason)}`);
    }
    width: '466px',
    height: '466px'
  });

  build() {}

  aboutToAppear() {
    this.privacyDialogController.open();
  }

  onPageShow() {
    this.isUpdate++;
  }
}

@CustomDialog
struct PermissionDialog {
  @State appName: string = '';
  @State isBottomPopover: boolean = true;
  @StorageLink('clicked') clicked: boolean = false;
  @Link @Watch('updateOnPageShow') isUpdate: number;
  dialog?: EnableNotificationDialog;
  session?: UIExtensionContentSession;
  controller?: CustomDialogController;

  build() {
    Flex({ justifyContent: FlexAlign.Center, alignItems: ItemAlign.Center }) {   
      Column() {
        Image(permission.icon)
        .width('92px')
        .height('92px')
        .margin({
            top: '2%'
        })

        Scroll() {
          Column() {
            Row() {
              Flex({ justifyContent: FlexAlign.Center }) {
                Text() {
                  Span(getContext(this).resourceManager.getStringSync(permission.label.id).replace('%s', this.appName))
                }
                .fontSize('38px')
                .fontColor('#FFFFFF')
                .fontWeight(500)
                .lineHeight('45px')
                .margin({
                  top: '4.1%',
                  left: '11.2%',
                  right: '11.2%'
                })
                .textAlign(TextAlign.Center)
              }
            }

            Row() {
              Flex({ justifyContent: FlexAlign.Center }) {
                Button($r('app.string.ALLOW'))
                .onClick(async (): Promise<void> => {
                  await this.enableNotification(true);
                })
                .backgroundColor('#1F71FF')
                .width('232px')
                .height('80px')  
                .fontColor('#FFFFFF')
                .fontSize('30px')
                .fontWeight(500)
              }
              .margin({top:'4.1%'})
            }

            Row() {
              Flex({ justifyContent: FlexAlign.Center }) {
                Button($r('app.string.BAN'))
                .onClick(async (): Promise<void> => {
                  await this.enableNotification(false);
                })
                .backgroundColor('#255EA1FF')
                .width('232px')
                .height('80px')  
                .fontColor('#5EA1FF')
                .fontSize('30px')
                .fontWeight(500)
              }
              .margin({top:'4.1%'})
            }
          }
        } 
        .scrollable(ScrollDirection.Vertical)
        .scrollBar(BarState.Off)
      } 
    }
    .margin({
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    })
    .width('100%')
    .height('100%')
    .backgroundColor('#35000000')
    .backgroundEffect({
      radius: 20,
      saturation: 50,
      adaptiveColor: AdaptiveColor.AVERAGE,
      blurOptions: {
        grayscale: [35, 35]
      }
    })
    
  }

  async updateApplicationName(bundleName: string): Promise<void> {
    console.info(TAG, `updateApplicationName bundleName: ${bundleName}`);
    try {
      let bundleFlags = bundleResourceManager.ResourceFlag.GET_RESOURCE_INFO_ALL;
      let resourceInfo = bundleResourceManager.getBundleResourceInfo(bundleName, bundleFlags);
      console.info(TAG, `applicationName name : ${JSON.stringify(resourceInfo.label)}`);
      let appName = resourceInfo.label;
      this.appName = titleTrim(appName);
      console.info(TAG, `hap label: ${this.appName}`);
    } catch (err) {
      console.error(TAG, `applicationName error : ${JSON.stringify(err)}`);
    }
  }

  async updateIsBottomPopover(): Promise<void> {
    let dis = display.getDefaultDisplaySync();
    let isVertical = dis.width <= dis.height;
    try {
      if (display.isFoldable()) {
        let foldStatus = display.getFoldStatus();
        if (foldStatus == display.FoldStatus.FOLD_STATUS_EXPANDED ||
          foldStatus == display.FoldStatus.FOLD_STATUS_HALF_FOLDED) {
            this.isBottomPopover = false;
            return;
        }
      }
    } catch (err) {
      console.error(TAG, 'Failed to get the device foldable status. Code: ' + JSON.stringify(err));
    }

    // read ccm configs
    let isBottomPopoverTemp = false;
    try {
      let filePaths = await configPolicy.getCfgFiles(Constants.CCM_CONFIG_PATH);
      for (let i = 0; i < filePaths.length; i++) {
        let res = fs.accessSync(filePaths[i]);
        if (res) {
          let fileContent = fs.readTextSync(filePaths[i]);
          let config: NotificationConfig = JSON.parse(fileContent);
          if (config.notificationAuthorizationWindow != undefined) {
            let windowConfig: NotificationAuthorizationWindow = config.notificationAuthorizationWindow;
            if (windowConfig.isBottomPopover != undefined) {
              isBottomPopoverTemp = windowConfig.isBottomPopover;
            }
          }
        }
      }
    } catch (error) {
      console.log(TAG, 'Failed get ccm files, Cause: ${JSON.stringify(err)}');
    }
    this.isBottomPopover = isBottomPopoverTemp && isVertical;
  }

  async updateStatus(): Promise<void> {
    let bundleNameObj = this.dialog?.want.parameters?.bundleName;
    let bundleName = bundleNameObj ? bundleNameObj.toString() : '';
    await this.updateApplicationName(bundleName);
    await this.updateIsBottomPopover();
  }

  async updateOnPageShow(): Promise<void> {
    if (this.isUpdate > 0) {
      await this.updateStatus();
    }
  }

  async aboutToAppear(): Promise<void> {
    this.dialog = storage.get('dialog') as EnableNotificationDialog;
    this.session = storage.get('session') as UIExtensionContentSession;
    try {
      await this.updateStatus();
    } catch (err) {
      console.error(TAG, `aboutToAppear error : + ${JSON.stringify(err)}`);
      await this.dialog?.destroyException();
      await this.session?.terminateSelf();
    }
  }

  async aboutToDisappear(): Promise<void> {
    console.info(TAG, `aboutToDisappear`);
    this.session?.terminateSelf();
  }

  async enableNotification(enabled: boolean): Promise<void> {
    console.info(TAG, `NotificationDialog enableNotification: ${enabled}`);
    try {
      await this.dialog?.publishButtonClickedEvent(enabled);
      this.clicked = true;
    } catch (err) {
      console.error(TAG, `NotificationDialog enable error, code is ${err?.code}`);
      await this.dialog?.destroyException();
    } finally {
      this.session?.terminateSelf();
    }
  }
}

interface NotificationConfig {
  notificationAuthorizationWindow: NotificationAuthorizationWindow;
}

interface NotificationAuthorizationWindow {
  isBottomPopover: boolean;
}

interface NotificationConfigAbc {
  deviceType: DeviceType;
}

interface DeviceType {
  isWatch: boolean;
}
